==========================
SINGLY LINKED LIST (SLL) ALGORITHMS WITH TIME COMPLEXITY
==========================

Node Structure:
---------------
class Node {
    int data;       
    Node next;      
    Node(int d) {
        data = d;
        next = null;
    }
}

==========================
ADT
insertFirst(data)
insertLast(data)
insertAt(index, data)
deleteFirst()
deleteLast()
deleteAt(index)
search(value)
display()
isEmpty()
==========================

Head Pointer:
-------------
Node head = null;

==========================
1) insertFirst(data)
--------------------------
Precondition: head may be null or point to first node
Postcondition: New node inserted at beginning; head updated
Time Complexity: Best = O(1), Average = O(1), Worst = O(1)

Algorithm:
1. Create a new node N with data = data
2. Set N.next = head
3. Update head = N
4. Return head
End Algorithm

==========================
2) insertLast(data)
--------------------------
Precondition: head may be null or list exists
Postcondition: New node inserted at end of list
Time Complexity: Best = O(1), Average = O(n), Worst = O(n)

Algorithm:
1. Create a new node N with data = data
2. If head == null
       head = N
       Return head
3. Else
       Set ptr = head
       While ptr.next != null
           ptr = ptr.next
       End While
       ptr.next = N
4. Return head
End Algorithm

==========================
3) insertAt(index, data)
--------------------------
Precondition: 0 ≤ index ≤ length of list
Postcondition: New node inserted at specified index
Time Complexity: Best = O(1), Average = O(n), Worst = O(n)

1. If index == 0
       Call insertFirst(data)
       Return
2. Create a new node N with data = data
3. Set ptr = head
4. For i = 0 to index - 2
       If ptr == null
           Print "Invalid index"
           Return
       ptr = ptr.next
5. If ptr == null
       Print "Invalid index"
       Return
6. N.next = ptr.next
7. ptr.next = N
8. Return head
End Algorithm

Algorithm insertAt(index, data)
1. If index < 0
       Print "Invalid index"
       Return
2. If index == 0
       Call insertFirst(data)
       Return
3. If head == null
       Print "List is empty"
       Return
4. Create a new node N with data = data
5. Set ptr = head
6. For i = 0 to index - 2
       If ptr == null
           Print "Invalid index"
           Return
       ptr = ptr.next
7. If ptr == null
       Print "Invalid index"
       Return
8. N.next = ptr.next
9. ptr.next = N
10. Return head
End Algorithm


==========================
4) deleteFirst()
--------------------------
Precondition: head != null
Postcondition: First node removed; head updated
Time Complexity: Best = O(1), Average = O(1), Worst = O(1)

Algorithm:
1. If head == null
       Print "List is empty"
       Return
2. head = head.next
3. Return head
End Algorithm

==========================
5) deleteLast()
--------------------------
Precondition: head != null
Postcondition: Last node removed
Time Complexity: Best = O(1), Average = O(n), Worst = O(n)

Algorithm:
1. If head == null
       Print "List is empty"
       Return
2. If head.next == null
       head = null
       Return
3. Set ptr = head
4. While ptr.next.next != null
       ptr = ptr.next
5. ptr.next = null
6. Return head
End Algorithm


Algorithm deleteLast()
1. If head == null
       Print "List is empty"
       Return
2. If head.next == null
       head = null
       Return
3. Set ptr = head
4. While ptr.next != null AND ptr.next.next != null
       ptr = ptr.next
5. ptr.next = null
6. Return head
End Algorithm


==========================
6) deleteAt(index)
--------------------------
Precondition: 0 ≤ index < length of list
Postcondition: Node at index removed
Time Complexity: Best = O(1), Average = O(n), Worst = O(n)

Algorithm:
1. If head == null
       Print "List is empty"
       Return
2. If index == 0
       Call deleteFirst()
       Return
3. Set ptr = head
4. For i = 0 to index - 2
       If ptr.next == null
           Print "Invalid index"
           Return
       ptr = ptr.next
5. If ptr.next == null
       Print "Invalid index"
       Return
6. ptr.next = ptr.next.next
7. Return head
End Algorithm


Algorithm deleteAt(index)
1. If index < 0
       Print "Invalid index"
       Return
2. If head == null
       Print "List is empty"
       Return
3. If index == 0
       Call deleteFirst()
       Return
4. Set ptr = head
5. For i = 0 to index - 2
       If ptr == null OR ptr.next == null
           Print "Invalid index"
           Return
       ptr = ptr.next
6. If ptr.next == null
       Print "Invalid index"
       Return
7. ptr.next = ptr.next.next
8. Return head
End Algorithm


==========================
7) search(value)
--------------------------
Precondition: Linked list exists
Postcondition: Prints position if value found; else "Not found"
Time Complexity: Best = O(1), Average = O(n), Worst = O(n)

Algorithm:
1. Set ptr = head
2. index = 0
3. While ptr != null
       If ptr.data == value
           Print "Found at index: " + index
           Return
       ptr = ptr.next
       index++
4. Print "Value not found"
End Algorithm

==========================
8) display()
--------------------------
Precondition: Linked list exists
Postcondition: All nodes printed in order
Time Complexity: Best = O(1), Average = O(n), Worst = O(n)

Algorithm:
1. If head == null
       Print "List is empty"
       Return
2. Set ptr = head
3. While ptr != null
       Print ptr.data + " -> "
       ptr = ptr.next
4. Print "null"
End Algorithm

==========================
9) isEmpty()
--------------------------
Precondition: Linked list exists
Postcondition: Returns true if list is empty; false otherwise
Time Complexity: Best = O(1), Average = O(1), Worst = O(1)

Algorithm:
1. If head == null
       Return true
2. Else
       Return false
End Algorithm

==========================

Algorithm: sizeSLL()

1. Set ptr = head
2. count = 0
3. While ptr != null
       3.1 count = count + 1
       3.2 ptr = ptr.next
4. Print "Size = " + count

==============================

$ sll_time_complexity_easy

1. insertFirst(data)
Best = O(1)
Insert at start → just update head pointer.
No walking through list.
Always very fast.

Average = O(1)
Even with many nodes → head update only.
No iteration needed.
Constant time.

Worst = O(1)
Same as best → head changes only.
List size doesn’t matter.
Quickest case.

2. insertLast(data)
Best = O(1)
List empty → node becomes head immediately.
No walking through list.
Fast operation.

Average = O(n)
List has some nodes → walk through about half to reach end.
Add new node.
Time grows with number of nodes.

Worst = O(n)
Walk through all nodes to insert at last.
Maximum steps needed.
Slowest case.

3. insertAt(index, data)
Best = O(1)
Index 0 → same as insertFirst.
Head updated directly.
Fastest operation.

Average = O(n)
Insert in middle → walk through half the list.
Update pointers after reaching position.
Time grows with index.

Worst = O(n)
Insert at last → walk through all nodes.
Update last pointer.
Takes longest time.

4. deleteFirst()
Best = O(1)
Remove first node → update head only.
No walking needed.
Fastest case.

Average = O(1)
Same as best → head changes only.
List size doesn’t matter.
Done quickly.

Worst = O(1)
Even with many nodes → head update only.
No iteration.
Always fast.

5. deleteLast()
Best = O(1)
Single-node list → set head = null.
No walking needed.
Fastest case.

Average = O(n)
List has nodes → walk to second-last node.
Set its next to null.
Time grows with list size.

Worst = O(n)
Delete last node → walk through all nodes.
Maximum steps needed.
Longest time.

6. deleteAt(index)
Best = O(1)
Index 0 → same as deleteFirst.
Update head pointer.
Fastest operation.

Average = O(n)
Delete middle node → walk through half list.
Update pointers after reaching node.
Time grows with index.

Worst = O(n)
Delete last node → walk through all nodes.
Maximum steps needed.
Longest time.

7. search(value)
Best = O(1)
Target is first node → found immediately.
One check only.
Fastest case.

Average = O(n)
Target somewhere in middle → check about half nodes.
Time grows with list size.
Moderate case.

Worst = O(n)
Target at last or not present → check all nodes.
Maximum steps needed.
Longest search time.

8. display()
Best = O(1)
Empty list → nothing to print.
Return immediately.
Fastest case.

Average = O(n)
Walk through list from head to tail.
Print each node.
Time grows with list size.

Worst = O(n)
Walk through all nodes.
Print each element.
Maximum steps.

9. isEmpty()
Best = O(1)
Check head → if null then empty.
No iteration needed.
Fastest case.

Average = O(1)
Always check head pointer.
List size doesn’t matter.
Done instantly.

Worst = O(1)
Same as best → only head check.
Constant time.
Always fast.

$ _
