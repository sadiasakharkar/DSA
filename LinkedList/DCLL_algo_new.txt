==========================
DOUBLY CIRCULAR LINKED LIST (DCLL) ALGORITHMS
==========================

// Node Structure:
class DCNode {
    int data;
    DCNode prev;
    DCNode next;

    DCNode(int d) {
        data = d;
        prev = null; 
        next = null; 
    }
}

Head & Tail Pointers:
DCNode head = null;
DCNode tail = null; 

ADT (Operations List):
insertFirst(data)
insertLast(data)
insertAt(index, data)
deleteFirst()
deleteLast()
deleteAt(index)
search(value)
displayForward()
displayReverse()
isEmpty()

==========================
1) Create Node and Insert at End (create / add)

Precondition: head may be null
Postcondition: New node added at end; tail updated; head.prev = tail; tail.next = head
Time Complexity: Best = O(1), Average = O(n), Worst = O(n)

Algorithm:
1. Create new node temp = new DCNode(data)
2. If head == null
       2.1 head = temp
       2.2 tail = temp
       2.3 head.prev = tail
       2.4 tail.next = head
       2.5 Return
3. Else
       3.1 Set ptr = head
       3.2 While ptr.next != head
              ptr = ptr.next
       3.3 End While
       3.4 ptr.next = temp
       3.5 temp.prev = ptr
       3.6 temp.next = head
       3.7 head.prev = temp
       3.8 tail = temp
4. Return head, tail

==========================
2) insertFirst(data)

Precondition: head may be null
Postcondition: New node added at beginning; head updated; tail.next = head; head.prev = tail
Time Complexity: Best = O(1), Average = O(1), Worst = O(1)

Algorithm:
1. Create new node temp = new DCNode(data)
2. If head == null
       2.1 head = temp
       2.2 tail = temp
       2.3 head.prev = tail
       2.4 tail.next = head
       2.5 Return
3. Else
       3.1 temp.next = head
       3.2 temp.prev = tail
       3.3 head.prev = temp
       3.4 tail.next = temp
       3.5 head = temp
4. Return head, tail

Socho naya VIP guest "Temp" entry gate se ghusta hai.
Temp bolta hai: “Main VIP hoon, mujhe front mein khada hona hai!” 😎
Woh seedha sabse aage jaake khada ho jata hai

Now adjustments begin:
Temp.next = Head → Purana leader (Head) ab uske peeche khada hota hai
Temp.prev = Tail → Backdoor se temp ne tail ka haath bhi pakad liya (circular)
Old Head.prev = Temp → Purane leader ne bhi new leader ka haath pakad liya
Tail.next = Temp → Last wala banda bhi new leader ko accept kar leta hai
Head = Temp → Ab sab kehte hai: “Haan bhai! Tu hi hamara new leader!”

==========================
3) insertLast(data)

Precondition: head may be null
Postcondition: New node added at end; tail updated; tail.next = head; head.prev = tail
Time Complexity: Best = O(1), Average = O(1), Worst = O(1)

Algorithm:
1. Create new node temp = new DCNode(data)
2. If head == null
       2.1 head = temp
       2.2 tail = temp
       2.3 head.prev = tail
       2.4 tail.next = head
       2.5 Return
3. Else
       3.1 tail.next = temp
       3.2 temp.prev = tail
       3.3 temp.next = head
       3.4 head.prev = temp
       3.5 tail = temp
4. Return head, tail

Ab ek aur banda aata hai — Temp2, lekin ye chill banda hai, kehta hai:
“Bhai mujhe VIP banne ka scene nahi… main queue ke end mein khada ho jaunga.”

Toh:
Old Tail.next = Temp2 → Purane last wale ne Temp2 ka haath pakda
Temp2.prev = Old Tail → Temp2 ne bhi haath wapas pakda
Temp2.next = Head → Circle maintain, temp2 ne head ka bhi haath pakda
Head.prev = Temp2 → Head bole: “Okay bhai tu bhi hamara circle mein”
Tail = Temp2 → Ab circle wale bolte: “Officially tu new tail hai!”

==========================
4) insertAt(index, data)
--------------------------
Precondition: 0 ≤ index ≤ length
Postcondition: Node inserted at given index; head/tail updated if needed; circular links maintained
Time Complexity: Best = O(1), Average = O(n), Worst = O(n)

Algorithm:
1. If index < 0
       Print "Invalid index"
       Return
2. If index == 0
       Call insertFirst(data)       // head me insert, circularity already handled
       Return
3. If head == null AND index > 0
       Print "List is empty"       // koi node nahi hai, invalid
       Return
4. Set ptr = head
5. For i = 0 to index - 1
       ptr = ptr.next
       If ptr == head
           Break                   // circular wrap, stop loop
6. Create new node temp = new DCNode(data)
7. temp.prev = ptr.prev
8. temp.next = ptr
9. ptr.prev.next = temp
10. ptr.prev = temp
11. If ptr == head
       tail = temp                 // agar end me insert hua to tail update
       head.prev = tail
       tail.next = head
12. Return head, tail

==========================
5) deleteFirst()

Precondition: head != null
Postcondition: First node removed; head updated; tail.next = head; head.prev = tail
Time Complexity: Best = O(1), Average = O(1), Worst = O(1)

Algorithm:
1. If head == null
       1.1 Print "List is empty"
       1.2 Return
2. If head == tail
       2.1 head = null
       2.2 tail = null
       2.3 Return
3. head = head.next
4. head.prev = tail
5. tail.next = head
6. Return head, tail

==========================
6) deleteLast()

Precondition: head != null
Postcondition: Last node removed; tail updated; tail.next = head; head.prev = tail
Time Complexity: Best = O(1), Average = O(1), Worst = O(1)

Algorithm:
1. If head == null
       1.1 Print "List is empty"
       1.2 Return
2. If head == tail
       2.1 head = null
       2.2 tail = null
       2.3 Return
3. tail = tail.prev
4. tail.next = head
5. head.prev = tail
6. Return head, tail

==========================
7) deleteAt(index)

Precondition: 0 ≤ index < length
Postcondition: Node at index removed; head/tail updated if needed
Time Complexity: Best = O(1), Average = O(n), Worst = O(n)

Algorithm:

1. If head == null
    1.1 Print "List is empty"
    1.2 Return
2. If index == 0
    2.1 Call deleteFirst()
    2.2 Return
3. Set ptr = head
4. For i = 0 to index - 1
    4.1 ptr = ptr.next
    4.2 If ptr == head
        Break // circular wrap, stop loop
5. ptr.prev.next = ptr.next
6. ptr.next.prev = ptr.prev
7.If ptr == tail
    7.1 tail = ptr.prev
    7.2 head.prev = tail
    7.3 tail.next = head
8.Return head, tail

==========================
8) search(value)

Precondition: List exists
Postcondition: Prints index if value found; else "Not found"
Time Complexity: Best = O(1), Average = O(n), Worst = O(n)

Algorithm:
1. If head == null
    1.1 Print "List is empty"
    1.2 Return
2. Set ptr = head
3. index = 0
4. Do
       4.1 If ptr.data == value
              4.1.1 Print "Found at index: " + index
              4.1.2 Return
       4.2 ptr = ptr.next
       4.3 index++
   While ptr != head
5. Print "Value not found"

==========================
9) displayForward()

Precondition: head may be null
Postcondition: Prints all nodes from head to last node
Time Complexity: Best = O(1), Average = O(n), Worst = O(n)

Algorithm:
1. If head == null
       1.1 Print "List is empty"
       1.2 Return
2. Set ptr = head
3. Do
       3.1 Print ptr.data + " <-> "
       3.2 ptr = ptr.next
   While ptr != head
4. Print "(head)"

==========================
10) displayReverse()

Precondition: head may be null
Postcondition: Prints all nodes from last to head
Time Complexity: Best = O(1), Average = O(n), Worst = O(n)

Algorithm:
1. If head == null
       1.1 Print "List is empty"
       1.2 Return
2. Set ptr = tail
3. Do
       3.1 Print ptr.data + " <-> "
       3.2 ptr = ptr.prev
   While ptr != tail
4. Print "(head)"

==========================
11) isEmpty()

Precondition: List exists
Postcondition: Returns true if list empty; else false
Time Complexity: Best = O(1), Average = O(1), Worst = O(1)

Algorithm:
1. If head == null
       1.1 Return true
2. Else
       2.1 Return false

==========================
