==========================
DOUBLY LINKED LIST (DLL) ALGORITHMS
==========================

Node Structure:
---------------
class Node {
    int data;
    Node prev;
    Node next;

    Node(int d) {
        data = d;
        prev = null;
        next = null;
    }
}

Head Pointer:
-------------
Node head = null;

ADT (Operations List):
---------------------
insertFirst(data)
insertLast(data)
insertAt(index, data)
deleteFirst()
deleteLast()
deleteAt(index)
search(value)
displayForward()
displayReverse()
isEmpty()

==========================
1) Create Node and Insert at End (create / add)
--------------------------
Precondition: head may be null
Postcondition: New node added at the end
Time Complexity: Best = O(1), Average = O(n), Worst = O(n)

Algorithm:
1. Create a new node temp = new Node(data)
2. Set temp.next = null, temp.prev = null
3. If head == null
       head = temp
       Return
4. Else
       Set ptr = head
       While ptr.next != null
           ptr = ptr.next
       End While
       ptr.next = temp
       temp.prev = ptr
5. Return head

==========================
2) insertFirst(data)
--------------------------
Precondition: head may be null
Postcondition: New node added at start
Time Complexity: Best = O(1), Average = O(1), Worst = O(1)

Algorithm:
1. Create new node temp = new Node(data)
2. temp.next = head
3. If head != null
       head.prev = temp
4. head = temp
5. Return head

==========================
3) insertLast(data)
--------------------------
Precondition: head may be null
Postcondition: New node added at end
Time Complexity: Best = O(1), Average = O(n), Worst = O(n)

Algorithm:
1. Create new node temp = new Node(data)
2. If head == null
       head = temp
       Return
3. Else
       Set ptr = head
       While ptr.next != null
           ptr = ptr.next
       End While
       ptr.next = temp
       temp.prev = ptr
4. Return head

==========================
4) insertAt(index, data)
--------------------------
Precondition: 0 ≤ index ≤ length of list
Postcondition: New node inserted at specified index
Time Complexity: Best = O(1), Average = O(n), Worst = O(n)

Algorithm insertAt(index, data)
1. If index < 0
       Print "Invalid index"
       Return
2. If index == 0
       Call insertFirst(data)
       Return
3. If head == null AND index > 0
       Print "List is empty"
       Return
4. Set ptr = head
5. For i = 0 to index - 2
       If ptr == null
           Print "Invalid index"
           Return
       ptr = ptr.next
6. If ptr == null
       Print "Invalid index"
       Return
7. Create new node temp = new Node(data)
8. temp.next = ptr.next
9. temp.prev = ptr
10. If ptr.next != null
        ptr.next.prev = temp
11. ptr.next = temp
12. Return head
End Algorithm
=========================
delete(value)
--------------------------
Precondition: head != null
Postcondition: First node with matching value removed; head updated if needed
Time Complexity: Best = O(1), Average = O(n), Worst = O(n)

1. If head == null
       Print "List is empty"
       Return
2. Set ptr = head
3. While ptr != null
       If ptr.data == value
           If ptr.prev != null
               ptr.prev.next = ptr.next
           Else
               head = ptr.next
           If ptr.next != null
               ptr.next.prev = ptr.prev
           Return head
       ptr = ptr.next
4. Print "Value not found"

==========================
5) deleteFirst()
--------------------------
Precondition: head != null
Postcondition: First node removed; head updated
Time Complexity: Best = O(1), Average = O(1), Worst = O(1)

Algorithm:
1. If head == null
       Print "List is empty"
       Return
2. head = head.next
3. If head != null
       head.prev = null
4. Return head

==========================
6) deleteLast()
--------------------------
Precondition: head != null
Postcondition: Last node removed
Time Complexity: Best = O(1), Average = O(n), Worst = O(n)

Algorithm:
1. If head == null
       Print "List is empty"
       Return
2. If head.next == null
       head = null
       Return
3. Set ptr = head
4. While ptr.next != null
       ptr = ptr.next
5. ptr.prev.next = null
6. Return head

==========================
7) deleteAt(index)
--------------------------
Precondition: 0 ≤ index < length
Postcondition: Node at index removed
Time Complexity: Best = O(1), Average = O(n), Worst = O(n)

1. If index < 0
       Print "Invalid index"
       Return
2. If head == null
       Print "List is empty"
       Return
3. If index == 0
       Call deleteFirst()
       Return
4. Set ptr = head
5. For i = 0 to index - 1
       If ptr == null OR ptr.next == null
           Print "Invalid index"
           Return
       ptr = ptr.next
6. If ptr == null
       Print "Invalid index"
       Return
7. If ptr.prev != null                            // Agar yeh first node nahi hai
       ptr.prev.next = ptr.next                  // Iska previous ab directly next wale ko point karega (node remove kar diya)
8. If ptr.next != null                           // Agar last node nahi hai
       ptr.next.prev = ptr.prev                  // Iska next ka previous ab ptr ke previous ko point karega
9. Return head
End Algorithm

==========================
8) search(value)
--------------------------
Precondition: Linked list exists
Postcondition: Prints index if value found; else "Not found"
Time Complexity: Best = O(1), Average = O(n), Worst = O(n)

Algorithm:
1. Set ptr = head
2. index = 0
3. While ptr != null
       If ptr.data == value
           Print "Found at index: " + index
           Return
       ptr = ptr.next
       index++
4. Print "Value not found"

==========================
9) displayForward()
--------------------------
Precondition: head may be null
Postcondition: Prints all nodes from head to tail
Time Complexity: Best = O(1), Average = O(n), Worst = O(n)

Algorithm:
1. If head == null
       Print "List is empty"
       Return
2. Set ptr = head
3. While ptr != null
       Print ptr.data + " <-> "
       ptr = ptr.next
4. Print "null"

==========================
10) displayReverse()
--------------------------
Precondition: head may be null
Postcondition: Prints all nodes from tail to head
Time Complexity: Best = O(1), Average = O(n), Worst = O(n)

Algorithm:
1. If head == null
       Print "List is empty"
       Return
2. Set ptr = head
3. Traverse to last node:
       While ptr.next != null
           ptr = ptr.next
4. While ptr != null
       Print ptr.data + " <-> "
       ptr = ptr.prev
5. Print "null"

==========================
11) isEmpty()
--------------------------
Precondition: Linked list exists
Postcondition: Returns true if list empty; else false
Time Complexity: Best = O(1), Average = O(1), Worst = O(1)

Algorithm:
1. If head == null
       Return true
2. Else
       Return false

==========================

Algorithm: sizeDLL()

1. Set ptr = head
2. count = 0
3. While ptr != null
       3.1 count = count + 1
       3.2 ptr = ptr.next
4. Print "Size = " + count

=============================


$ dll_time_complexity_easy

1. Create Node & Insert at End
Best = O(1)
List is empty → node becomes head immediately.
No need to move through the list.
Very fast operation.

Average = O(n)
List has some nodes → go through about half the nodes.
Stop at the end and add the new node.
Time grows with number of nodes.

Worst = O(n)
List is full → go through all nodes to reach the end.
Add new node at the last position.
Takes the most time.

2. insertFirst(data)
Best = O(1)
Insert at the start → update head and new node only.
No walking through list.
Always fast.

Average = O(1)
Same as best case → list size does not matter.
Just update pointers.
Done in constant time.

Worst = O(1)
Even with many nodes → only head changes.
No iteration needed.
Always quick.

3. insertLast(data)
Best = O(1)
List empty → new node becomes head.
No walking through list.
Fastest case.

Average = O(n)
List has nodes → walk through half of them to reach end.
Add new node at last.
Time grows with list size.

Worst = O(n)
Walk through all nodes to insert at the last.
Maximum number of steps.
Slowest case.

4. insertAt(index, data)
Best = O(1)
Index 0 → same as insertFirst.
Update head only.
Fast operation.

Average = O(n)
Insert in middle → walk through half the list.
Update pointers after reaching position.
Time grows with index.

Worst = O(n)
Insert at last → walk through all nodes.
Update pointers at end.
Takes longest time.

5. deleteFirst()
Best = O(1)
Always remove first node → update head pointer.
No walking needed.
Very fast.

Average = O(1)
Same as best → list size doesn’t matter.
Just head pointer changes.
Constant time.

Worst = O(1)
Even if list is long → just remove first node.
No iteration.
Quickest possible.

6. deleteLast()
Best = O(1)
Single-node list → set head = null.
No walking needed.
Done quickly.

Average = O(n)
List has nodes → walk to last node.
Remove last node.
Time grows with number of nodes.

Worst = O(n)
Delete last node → walk through all nodes.
Maximum steps needed.
Slowest case.

7. deleteAt(index)
Best = O(1)
Index 0 → call deleteFirst.
Update head only.
Fastest.

Average = O(n)
Delete middle node → walk half the list.
Update pointers after reaching it.
Time grows with index.

Worst = O(n)
Delete last node → walk all nodes.
Maximum steps needed.
Longest time.

8. search(value)
Best = O(1)
Target is first node → found immediately.
One check only.
Done fast.

Average = O(n)
Target somewhere in middle → check half nodes on average.
Time grows with list size.
Moderate time.

Worst = O(n)
Target last or not there → check all nodes.
Maximum steps.
Longest search time.

9. displayForward()
Best = O(1)
List empty → nothing to show.
Return immediately.
Constant time.

Average = O(n)
Walk from head to tail.
Print each node.
Time grows with list size.

Worst = O(n)
Walk entire list → print all nodes.
Maximum steps.
Longest display time.

10. displayReverse()
Best = O(1)
List empty → nothing to show.
Return immediately.
Fastest case.

Average = O(n)
Walk to last node, then back to head.
Print each node while going.
Time grows with list size.

Worst = O(n)
List full → walk forward and backward.
Print all nodes.
Maximum steps.

11. isEmpty()
Best = O(1)
Check if head is null.
No walking needed.
Instant result.

Average = O(1)
Always check head.
Does not depend on size.
Quick check.

Worst = O(1)
Same → head check only.
Constant time.
Done fast.

$ _
