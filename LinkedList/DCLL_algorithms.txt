==========================
DOUBLY CIRCULAR LINKED LIST (DCLL) ALGORITHMS
==========================

Node Structure:
---------------
class DCNode {
    int data;
    DCNode prev;
    DCNode next;

    DCNode(int d) {
        data = d;
        prev = null;
        next = null;
    }
}

Head Pointer:
-------------
DCNode head = null;

ADT (Operations List):
---------------------
insertFirst(data)
insertLast(data)
insertAt(index, data)
deleteFirst()
deleteLast()
deleteAt(index)
search(value)
displayForward()
displayReverse()
isEmpty()

==========================
1) Create Node and Insert at End (create / add)
--------------------------
Precondition: head may be null
Postcondition: New node added at end; last node points to head; head.prev points to last node
Time Complexity: Best = O(1), Average = O(n), Worst = O(n)

Algorithm:
1. Create new node temp = new DCNode(data)
2. If head == null
       head = temp
       temp.next = head
       temp.prev = head
       Return
3. Else
       Set ptr = head
       While ptr.next != head
           ptr = ptr.next
       End While
       ptr.next = temp
       temp.prev = ptr
       temp.next = head
       head.prev = temp
4. Return head

==========================
2) insertFirst(data)
--------------------------
Precondition: head may be null
Postcondition: New node added at beginning; last node points to new head
Time Complexity: Best = O(1), Average = O(1), Worst = O(1)

Algorithm:
1. Create new node temp = new DCNode(data)
2. If head == null
       head = temp
       temp.next = head
       temp.prev = head
       Return
3. Else
       Set last = head.prev
       temp.next = head
       temp.prev = last
       last.next = temp
       head.prev = temp
       head = temp
4. Return head

==========================
3) insertLast(data)
--------------------------
Precondition: head may be null
Postcondition: New node added at end; last node points to head
Time Complexity: Best = O(1), Average = O(1), Worst = O(1)

Algorithm:
1. Create new node temp = new DCNode(data)
2. If head == null
       head = temp
       temp.next = head
       temp.prev = head
       Return
3. Else
       Set last = head.prev
       last.next = temp
       temp.prev = last
       temp.next = head
       head.prev = temp
4. Return head

==========================
4) insertAt(index, data)
--------------------------
Precondition: 0 ≤ index ≤ length
Postcondition: Node inserted at given index
Time Complexity: Best = O(1), Average = O(n), Worst = O(n)

Algorithm:
1. If index == 0
       Call insertFirst(data)
       Return
2. Create new node temp = new DCNode(data)
3. Set ptr = head
4. For i = 0 to index - 1
       ptr = ptr.next
5. temp.prev = ptr.prev
6. temp.next = ptr
7. ptr.prev.next = temp
8. ptr.prev = temp
9. If index == 0
       head = temp

==========================
5) deleteFirst()
--------------------------
Precondition: head != null
Postcondition: First node removed; head updated; last node points to new head
Time Complexity: Best = O(1), Average = O(1), Worst = O(1)

Algorithm:
1. If head == null
       Print "List is empty"
       Return
2. If head.next == head
       head = null
       Return
3. Set last = head.prev
4. head = head.next
5. head.prev = last
6. last.next = head
7. Return head

==========================
6) deleteLast()
--------------------------
Precondition: head != null
Postcondition: Last node removed; last node points to head
Time Complexity: Best = O(1), Average = O(1), Worst = O(1)

Algorithm:
1. If head == null
       Print "List is empty"
       Return
2. If head.next == head
       head = null
       Return
3. Set last = head.prev
4. last.prev.next = head
5. head.prev = last.prev
6. Return head

==========================
7) deleteAt(index)
--------------------------
Precondition: 0 ≤ index < length
Postcondition: Node at index removed
Time Complexity: Best = O(1), Average = O(n), Worst = O(n)

Algorithm:
1. If head == null
       Print "List is empty"
       Return
2. If index == 0
       Call deleteFirst()
       Return
3. Set ptr = head
4. For i = 0 to index - 1
       ptr = ptr.next
5. ptr.prev.next = ptr.next
6. ptr.next.prev = ptr.prev
7. Return head

==========================
8) search(value)
--------------------------
Precondition: List exists
Postcondition: Prints index if value found; else "Not found"
Time Complexity: Best = O(1), Average = O(n), Worst = O(n)

Algorithm:
1. Set ptr = head
2. index = 0
3. Do
       If ptr.data == value
           Print "Found at index: " + index
           Return
       ptr = ptr.next
       index++
   While ptr != head
4. Print "Value not found"

==========================
9) displayForward()
--------------------------
Precondition: head may be null
Postcondition: Prints all nodes from head to last node
Time Complexity: Best = O(1), Average = O(n), Worst = O(n)

Algorithm:
1. If head == null
       Print "List is empty"
       Return
2. Set ptr = head
3. Do
       Print ptr.data + " <-> "
       ptr = ptr.next
   While ptr != head
4. Print "(head)"

==========================
10) displayReverse()
--------------------------
Precondition: head may be null
Postcondition: Prints all nodes from last to head
Time Complexity: Best = O(1), Average = O(n), Worst = O(n)

Algorithm:
1. If head == null
       Print "List is empty"
       Return
2. Set ptr = head.prev  // start from last node
3. Do
       Print ptr.data + " <-> "
       ptr = ptr.prev
   While ptr != head.prev
4. Print "(head)"

==========================
11) isEmpty()
--------------------------
Precondition: List exists
Postcondition: Returns true if list empty; else false
Time Complexity: Best = O(1), Average = O(1), Worst = O(1)

Algorithm:
1. If head == null
       Return true
2. Else
       Return false

==========================

$ dcll_time_complexity_easy

1. insertFirst(data)
Best = O(1)
List empty → new node becomes head immediately.
Pointers updated to point to itself.
Very fast, no walking needed.

Average = O(1)
List has nodes → just update head and last pointers.
No iteration required.
Constant time.

Worst = O(1)
Even with many nodes → update head and last.
Size doesn’t matter.
Always quick.

2. insertLast(data)
Best = O(1)
List empty → new node becomes head.
Head and last pointers updated.
Done immediately.

Average = O(1)
List has nodes → update last node pointers.
No walking through list needed.
Still very fast.

Worst = O(1)
Same as best → only pointer updates.
List size doesn’t affect time.
Always fast.

3. insertAt(index, data)
Best = O(1)
Index 0 → same as insertFirst.
Update head and last pointers.
Fastest insertion.

Average = O(n)
Index in middle → walk through nodes to reach position.
Update prev and next pointers.
Time grows with index.

Worst = O(n)
Index at last → walk through all nodes.
Update pointers after reaching position.
Takes the longest time.

4. deleteFirst()
Best = O(1)
Remove head → update head and last pointers.
No walking needed.
Fastest case.

Average = O(1)
List has multiple nodes → update pointers only.
No iteration required.
Done quickly.

Worst = O(1)
Even with many nodes → head and last updated.
List size doesn’t matter.
Always fast.

5. deleteLast()
Best = O(1)
Single node → set head = null.
No walking needed.
Fastest case.

Average = O(1)
List has multiple nodes → update last.prev.next and head.prev.
No iteration required.
Done quickly.

Worst = O(1)
Even with many nodes → only pointer updates.
Constant time.
Always fast.

6. deleteAt(index)
Best = O(1)
Index 0 → same as deleteFirst.
Update pointers only.
Fastest deletion.

Average = O(n)
Index in middle → walk to that node.
Update prev and next pointers.
Time grows with index.

Worst = O(n)
Index at last → walk through all nodes.
Update pointers after reaching node.
Longest time.

7. search(value)
Best = O(1)
Target is head → found immediately.
One check only.
Fastest case.

Average = O(n)
Target somewhere in the list → check half nodes on average.
Time grows with list size.
Moderate case.

Worst = O(n)
Target is last or not present → check all nodes.
Maximum steps needed.
Longest search time.

8. displayForward()
Best = O(1)
Empty list → nothing to print.
Return immediately.
Fastest case.

Average = O(n)
Walk through all nodes from head to last.
Print each node.
Time grows with number of nodes.

Worst = O(n)
All nodes printed.
Maximum steps taken.
Longest time.

9. displayReverse()
Best = O(1)
Empty list → nothing to print.
Return immediately.
Fastest case.

Average = O(n)
Walk from last to head node.
Print each element.
Time grows with number of nodes.

Worst = O(n)
Print all nodes in reverse.
Maximum steps needed.
Longest time.

10. isEmpty()
Best = O(1)
Check head → null means empty.
No iteration needed.
Always fast.

Average = O(1)
Always just check head pointer.
List size doesn’t matter.
Done instantly.

Worst = O(1)
Same as best → only head check.
Constant time.
Always fast.

$ _
