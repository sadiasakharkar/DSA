Algorithm: LinearSearch(arr, target)
Precondition: arr is an array, target is the element to search
Postcondition: Returns the index of target if found; otherwise returns -1
Linear Search: Time Complexity: Best = O(1), Average = O(n), Worst = O(n)


Steps:
1.  Check if array is empty
    If length(arr) = 0 then
        Return -1
2.  Loop through the array
    For i = 0 to length(arr) - 1 do
         If arr[i] = target then
              Return i // Element found
3.  Target not found
    Return -1
End Algorithm

-------------------------------------------------------------

Algorithm: BinarySearch(arr, target)
Precondition: arr is a sorted array
Postcondition: returns index of target if found, else -1
Binary Search: Time Complexity: Best = O(1), Average = O(log n), Worst = O(log n)


1. start = 0
2. end = length(arr) - 1

3. while start <= end do
       mid = start + (end - start) / 2   // middle element
       
       if arr[mid] = target then
           return mid     // element found
       else if target < arr[mid] then
           end = mid - 1  // search left half
       else
           start = mid + 1 // search right half
           
4. return -1   // element not found

End Algorithm

=============================================================

Algorithm: InsertionSort(arr)
Precondition: arr is an array
Postcondition: arr is sorted in ascending order
Insertion Sort: Time Complexity: Best = O(n), Average = O(nÂ²), Worst = O(nÂ²)


1. for i = 0 to length(arr) - 2 do        // outer loop for each element
       for j = i + 1 down to 1 do        // move element left in sorted portion
           if arr[j] < arr[j-1] then
               swap arr[j], arr[j-1]     // move element left if smaller
           else
               break                     // element is in correct position
           end if
       end for
2. return arr

End Algorithm


Algorithm: InsertionSortDescending(arr)
Precondition: arr is an array
Postcondition: arr is sorted in descending order
Insertion Sort (Descending): Time Complexity: Best = O(n), Average = O(nÂ²), Worst = O(nÂ²)


1. for i = 0 to length(arr) - 2 do
       for j = i + 1 down to 1 do
           if arr[j] > arr[j-1] then        // FLIPPED sign
               swap arr[j], arr[j-1]
           else
               break
           end if
       end for
2. return arr

End Algorithm

--------------------------------------------------------------------

Algorithm: BubbleSort(arr)
Precondition: arr is an array
Postcondition: arr is sorted in ascending order
Bubble Sort: Time Complexity: Best = O(n), Average = O(nÂ²), Worst = O(nÂ²)


1. for i = 0 to length(arr) - 1 do
       swapped = false   // track if any swap happened
       
       for j = 1 to length(arr) - i - 1 do
           if arr[j] < arr[j-1] then
               swap arr[j], arr[j-1]
               swapped = true
           end if
       end for
       
       if swapped = false then
           break   // no swaps â†’ array already sorted
       end if
2. return arr

End Algorithm

Algorithm: BubbleSortDescending(arr)
Precondition: arr is an array
Postcondition: arr is sorted in descending order
Bubble Sort (Descending): Time Complexity: Best = O(n), Average = O(nÂ²), Worst = O(nÂ²)


1. for i = 0 to length(arr) - 1 do
       swapped = false
       
       for j = 1 to length(arr) - i - 1 do
           if arr[j] > arr[j-1] then      // Just flip the sign!
               swap arr[j], arr[j-1]
               swapped = true
           end if
       end for
       
       if swapped = false then
           break
       end if
2. return arr

End Algorithm


---------------------------------------------------------------------

Algorithm: QuickSort(arr, low, high)
Precondition: arr is an array, low and high are indices
Postcondition: arr is sorted in ascending order
Quick Sort: Time Complexity: Best = O(n log n), Average = O(n log n), Worst = O(nÂ²)

Main Steps:
1. n = length(arr)
2. Call QuickSort(arr, 0, n - 1)
3. Print arr

Function QuickSort(arr, low, high):
1. if low < high then
       pivotIndex = Partition(arr, low, high)
       QuickSort(arr, low, pivotIndex - 1)    // sort left subarray
       QuickSort(arr, pivotIndex + 1, high)   // sort right subarray
2. end if
End Function

Function Partition(arr, low, high):
1. pivot = arr[high]       // choose last element as pivot
2. i = low - 1
3. for j = low to high - 1 do
       if arr[j] < pivot then
           i = i + 1
           swap arr[i] and arr[j]
       end if
4. end for
5. i = i + 1
6. swap arr[i] and arr[high]   // place pivot in correct position
7. return i    // pivot index
End Function

-------------------------------------------------------------------------

1. Linear Search

Best Case â€” O(1)
The element is found at the very first position.
Only one comparison is needed, so it finishes immediately.
This is the fastest situation possible for linear search.

Average Case â€” O(n)
The element is somewhere in the middle of the array.
About half of the elements (n/2) are checked before finding it.
The number of comparisons grows directly with the size of the list.

Worst Case â€” O(n)
The element is at the end or not present at all.
All n elements must be compared one by one.
Hence, the time increases linearly with the input size.

âš¡ 2. Binary Search

Best Case â€” O(1)
The middle element is exactly the target value.
The element is found in the first comparison itself.
This happens rarely but is the fastest possible case.

Average Case â€” O(log n)
Each step divides the array into half of its previous size.
It takes around logâ‚‚n comparisons to locate the target.
This makes it much faster than linear search for large data.

Worst Case â€” O(log n)
Even if the element is not found, the array keeps halving.
The process continues until only one element remains.
Total comparisons are about logâ‚‚n before the search ends.

ðŸ«§ 3. Bubble Sort

Best Case â€” O(n)
The array is already sorted in correct order.
Only one pass through nâ€“1 comparisons is made.
No swaps are required, so sorting completes quickly.

Average Case â€” O(nÂ²)
The elements are randomly arranged in the array.
Each pass performs several comparisons and swaps.
It takes roughly nÂ²/2 total operations to sort everything.

Worst Case â€” O(nÂ²)
The array is in completely reverse order.
Every element must be compared and swapped repeatedly.
This causes the maximum number of passes and operations.

âœï¸ 4. Insertion Sort

Best Case â€” O(n)
The array is already sorted in increasing order.
Each element is checked once and placed correctly.
Only nâ€“1 comparisons are made with no shifting needed.

Average Case â€” O(nÂ²)
Elements are in random positions within the array.
Each insertion takes about n/2 comparisons and shifts.
Hence, total time increases roughly with nÂ²/4 operations.

Worst Case â€” O(nÂ²)
The array is sorted in reverse order.
Each new element must move past all previous ones.
So, it performs n(nâ€“1)/2 comparisons and many shifts.

âš™ï¸ 5. Quick Sort

Best Case â€” O(n log n)
The pivot divides the array into two equal halves each time.
Each level of recursion handles balanced partitions efficiently.
Total work is about n Ã— logâ‚‚n comparisons to complete sorting.

Average Case â€” O(n log n)
Random pivot choices usually make fairly even partitions.
The recursion depth remains around logâ‚‚n levels.
So, total comparisons stay close to n logâ‚‚n on average.

Worst Case â€” O(nÂ²)
Pivot always becomes the smallest or largest element.
This creates highly unbalanced partitions at every step.
As a result, sorting needs n(nâ€“1)/2 comparisons in total.