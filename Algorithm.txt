Algorithm: LinearSearch(arr, target)
Precondition: arr is an array, target is the element to search
Postcondition: Returns the index of target if found; otherwise returns -1
Steps:
1.  Check if array is empty
    If length(arr) = 0 then
        Return -1
2.  Loop through the array
    For i = 0 to length(arr) - 1 do
         If arr[i] = target then
              Return i // Element found
3.  Target not found
    Return -1
End Algorithm



Algorithm: BinarySearch(arr, target)
Precondition: arr is a sorted array
Postcondition: returns index of target if found, else -1

1. start = 0
2. end = length(arr) - 1

3. while start <= end do
       mid = start + (end - start) / 2   // middle element
       
       if arr[mid] = target then
           return mid     // element found
       else if target < arr[mid] then
           end = mid - 1  // search left half
       else
           start = mid + 1 // search right half
           
4. return -1   // element not found

End Algorithm



Algorithm: InsertionSort(arr)
Precondition: arr is an array
Postcondition: arr is sorted in ascending order

1. for i = 1 to length(arr) - 1 do
       j = i
       while j > 0 AND arr[j] < arr[j-1] do
           swap arr[j], arr[j-1]   // move element left if smaller
           j = j - 1
       end while
2. return arr

End Algorithm



Algorithm: BubbleSort(arr)
Precondition: arr is an array
Postcondition: arr is sorted in ascending order

1. for i = 0 to length(arr) - 1 do
       swapped = false   // track if any swap happened
       
       for j = 1 to length(arr) - i - 1 do
           if arr[j] < arr[j-1] then
               swap arr[j], arr[j-1]
               swapped = true
           end if
       end for
       
       if swapped = false then
           break   // no swaps â†’ array already sorted
       end if
2. return arr

End Algorithm



Algorithm: QuickSort(arr, low, high)
Precondition: arr is an array, low and high are indices
Postcondition: arr is sorted in ascending order

Main Steps:
1. n = length(arr)
2. Call QuickSort(arr, 0, n - 1)
3. Print arr

Function QuickSort(arr, low, high):
1. if low < high then
       pivotIndex = Partition(arr, low, high)
       QuickSort(arr, low, pivotIndex - 1)    // sort left subarray
       QuickSort(arr, pivotIndex + 1, high)   // sort right subarray
2. end if
End Function

Function Partition(arr, low, high):
1. pivot = arr[high]       // choose last element as pivot
2. i = low - 1
3. for j = low to high - 1 do
       if arr[j] < pivot then
           i = i + 1
           swap arr[i] and arr[j]
       end if
4. end for
5. i = i + 1
6. swap arr[i] and arr[high]   // place pivot in correct position
7. return i    // pivot index
End Function
