===============================
BINARY SEARCH TREE AS ADT
===============================

Definition:
Binary Search Tree ADT defines operations to create, insert, search,
delete, and traverse nodes in a hierarchical structure
where each left child is less than parent and right child is greater than parent.


----------------------------------------------------------
Function Name: createTree()
----------------------------------------------------------
Precondition: Tree is empty.
Postcondition: Root node is created with user input value.
Time Complexity: O(1)

Pseudocode:
Function createTree()
    Input value for root
    root equals new Node(value)
    Print "Root created with value" value
End Function


----------------------------------------------------------
Function Name: insert(root, value)
----------------------------------------------------------
Precondition: Tree exists.
Postcondition: Node inserted maintaining BST property.
Time Complexity:
    Best Case O(log n)
    Average Case O(log n)
    Worst Case O(n) if tree is skewed

Pseudocode:
Function insert(root, value)
    If root is null then
        root equals new Node(value)
        Return root
    End If

    If value less than root.data then
        root.left equals insert(root.left, value)
    Else if value greater than root.data then
        root.right equals insert(root.right, value)
    Else
        Print "Duplicate value ignored"
    End If

    Return root
End Function


----------------------------------------------------------
Function Name: search(root, key)
----------------------------------------------------------
Precondition: Tree exists.
Postcondition: Returns true if key is found, false otherwise.
Time Complexity:
    Best Case O(1)
    Average Case O(log n)
    Worst Case O(n) if tree is skewed

Pseudocode:
Function search(root, key)
    If root is null then
        Return false
    End If
    If key equals root.data then
        Return true
    Else if key less than root.data then
        Return search(root.left, key)
    Else
        Return search(root.right, key)
    End If
End Function


----------------------------------------------------------
Function Name: inorder(root)
----------------------------------------------------------
Precondition: Tree exists.
Postcondition: Prints nodes in ascending order.
Time Complexity: O(n)

Pseudocode:
Function inorder(root)
    If root is null then
        Return
    End If
    inorder(root.left)
    Print root.data
    inorder(root.right)
End Function


----------------------------------------------------------
Function Name: preorder(root)
----------------------------------------------------------
Precondition: Tree exists.
Postcondition: Prints nodes in Root Left Right order.
Time Complexity: O(n)

Pseudocode:
Function preorder(root)
    If root is null then
        Return
    End If
    Print root.data
    preorder(root.left)
    preorder(root.right)
End Function


----------------------------------------------------------
Function Name: postorder(root)
----------------------------------------------------------
Precondition: Tree exists.
Postcondition: Prints nodes in Left Right Root order.
Time Complexity: O(n)

Pseudocode:
Function postorder(root)
    If root is null then
        Return
    End If
    postorder(root.left)
    postorder(root.right)
    Print root.data
End Function


----------------------------------------------------------
Function Name: findMin(root)
----------------------------------------------------------
Precondition: Tree exists.
Postcondition: Returns node with minimum value in subtree.
Time Complexity:
    Best Case O(log n)
    Average Case O(log n)
    Worst Case O(n)

Pseudocode:
Function findMin(root)
    While root.left is not null do
        root equals root.left
    End While
    Return root
End Function


----------------------------------------------------------
Function Name: delete(root, key)
----------------------------------------------------------
Precondition: Tree exists.
Postcondition: Deletes node with specified key, updates tree.
Time Complexity:
    Best Case O(log n)
    Average Case O(log n)
    Worst Case O(n)

Pseudocode:
Function delete(root, key)
    If root is null then
        Print "Value not found"
        Return null
    End If

    If key less than root.data then
        root.left equals delete(root.left, key)
    Else if key greater than root.data then
        root.right equals delete(root.right, key)
    Else
        // Node found
        If root.left is null and root.right is null then
            Return null
        Else if root.left is null then
            Return root.right
        Else if root.right is null then
            Return root.left
        Else
            successor equals findMin(root.right)
            root.data equals successor.data
            root.right equals delete(root.right, successor.data)
        End If
    End If
    Return root
End Function
