===============================
BINARY SEARCH TREE AS ADT
===============================

Definition:
Binary Search Tree ADT defines operations to create, insert, search,
delete, and traverse nodes in a hierarchical structure
where each left child is less than parent and right child is greater than parent.

----------------------------------------------------------
createTree()
----------------------------------------------------------
Precondition: Tree is empty
Postcondition: Root node is created with user input value
Time Complexity: O(1)

1. Input value for root
2. root = new Node(value)
3. root.parent = null   // root has no parent
4. Print "Root created with value", value

----------------------------------------------------------
insert(root, value)
----------------------------------------------------------
Precondition: Tree exists
Postcondition: Node inserted maintaining BST property
Time Complexity: Best = O(log n), Average = O(log n), Worst = O(n)

1. If root == null
       root = new Node(value)
       root.parent = parent_node  // set parent pointer
       Return root
2. If value < root.data
       root.left = insert(root.left, value)
       root.left.parent = root
3. Else if value > root.data
       root.right = insert(root.right, value)
       root.right.parent = root
4. Else
       Print "Duplicate value ignored"
5. Return root

----------------------------------------------------------
search(root, key)
----------------------------------------------------------
Precondition: Tree exists
Postcondition: Returns true if key is found, false otherwise
Time Complexity: Best = O(1), Average = O(log n), Worst = O(n)

1. If root == null
       Return false
2. If key == root.data
       Return true
3. Else if key < root.data
       Return search(root.left, key)
4. Else
       Return search(root.right, key)

----------------------------------------------------------
inorder(root)
----------------------------------------------------------
Precondition: Tree exists
Postcondition: Prints nodes in ascending order
Time Complexity: O(n)

1. If root == null
       Return
2. inorder(root.left)
3. Print root.data
4. inorder(root.right)

----------------------------------------------------------
preorder(root)
----------------------------------------------------------
Precondition: Tree exists
Postcondition: Prints nodes in Root Left Right order
Time Complexity: O(n)

1. If root == null
       Return
2. Print root.data
3. preorder(root.left)
4. preorder(root.right)

----------------------------------------------------------
postorder(root)
----------------------------------------------------------
Precondition: Tree exists
Postcondition: Prints nodes in Left Right Root order
Time Complexity: O(n)

1. If root == null
       Return
2. postorder(root.left)
3. postorder(root.right)
4. Print root.data

----------------------------------------------------------
findMin(root)
----------------------------------------------------------
Precondition: Tree exists
Postcondition: Returns node with minimum value in subtree
Time Complexity: Best = O(log n), Average = O(log n), Worst = O(n)

1. If root == null
       Return null
2. While root.left != null
       root = root.left
3. Return root

----------------------------------------------------------
delete(root, key)
----------------------------------------------------------
Precondition: Tree exists
Postcondition: Deletes node with specified key; updates parent/root pointers
Time Complexity: Best = O(log n), Average = O(log n), Worst = O(n)

1. If root == null
       Print "Tree empty or value not found"
       Return null

2. If key < root.data
       root.left = delete(root.left, key)
       If root.left != null
           root.left.parent = root
       Return root

3. Else if key > root.data
       root.right = delete(root.right, key)
       If root.right != null
           root.right.parent = root
       Return root

4. Else
       // Node found â€” handle 3 cases
       a. If root.left == null AND root.right == null
              If root.parent != null
                  If root.parent.left == root
                      root.parent.left = null
                  Else
                      root.parent.right = null
              Free(root)
              Return null

       b. Else if root.left == null
              temp = root.right
              temp.parent = root.parent
              Free(root)
              Return temp

       c. Else if root.right == null
              temp = root.left
              temp.parent = root.parent
              Free(root)
              Return temp

       d. Else
              successor = findMin(root.right)
              root.data = successor.data
              root.right = delete(root.right, successor.data)
              If root.right != null
                  root.right.parent = root
              Return root

5. Return root
